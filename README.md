# android-learning
Project for Android learning

_p0261_intentfilter_

Налаштування фільтрів на відкриття інших Activity (відкриття через фільтри без передачі додаткових даних)

_p0271_getintentaction_

При відкритті Activity отримання параметру по якому фільтру (intent filter) відкриття проводиться

_p0281_intentextras_

Передача додаткових данних з одного Activity в другий через об'єкт Intent

_p0291_simpleactivityresult_

Відкриття іншого Activity з возвратом результату після свого закриття (наприклад відкриття форми підбору)

_p0301_activityresult_

Обробка результатів двох різних Activity одним обробником (requestCode, resultCode)

_p0311_simpleintents_

За допомогою інтентів відкриття програм для здійснення операцій (напр. набір номера, показ місця на карті,
відкриття посилання. Передача параметрів відкриття за допомогою Uri (напр. "tel:112334455")

_p0321_simplebrowser_

Простий браузер: на екрані кнопка по нажиманні на яку пробується відкрити сайт. На другому
вікні настроєний інтент-фільтр, який добавляє його в вікно вибору програми для відкриття сайту.
Якраз на ньому і компонент для відображення сайту.

_p0341_simplemysqllite_

Робота з базами данних: ініціалізація БД, добавлення в базу, очистка бази, Читання всієї бази.
Також добавлено читання по айдішці, обновлення по айдішці і видалення по айдішці.

_p0361_sqlitequery_

Робота з базами данних: приклади селекта з умовою, групіовка, селект з умовою по групіровці (having),
сортування і т.д. з допомогою метода quety об'єкта SQLiteDatabase.
Також імітація нажимання кнопки (через визов метода onClick лістенера, якому передається об'єкт кнопки.
Якщо класс має інтерфейс onClick... , то метод onClick виконується напряму (і йому годується все та ж кнопка).

_p0371_sqlinnerjoin_

Консольний приклад як виконувати складні запроси через чистий текстовий запрос (зокрема дані з двох
таблиці лівим з'єднанням).
добавлено аналогічний приклад через об'єктну модель (query), правдо з выдбором.

_p0381_sqlitetransactions_

Консольний приклад використання транзакцій. Також приклад як працює блокіровка при транзакції,
аналогіно про те що в межах об'єкта SQLiteOpenDBHelper може бути не більше 1-го з'єднання (
при повторному полученні не відкривається нове, а віддається існуюче з'єднання.) 

_p0391_sqliteonupdatedb_

Приклад роботи програми при переході з одної версії БД на другу (зміна структури БД) через
OnUpdate SQLiteOpenDBHelper.

_p0401_layoutInflater_

Експеременти з layoutInflater: добавляння елементів з іншого xml-файла: параметри layoutInflate

_p0411_layoutInflaterlist_

Генерація простого списку з допомогою inflater. Ключевим моментом було що ми з допомогою
inflate() генерим рядок, але з останнім параметром в false, заповняем полуений об'єкт, а
потім вже вручну добавляем його в LinearView.

_p0421_simplelist_

Генерація списку з допомогою адаптора по шаблону рядка.

_p0431_listsimplechoice_

Генерація списку з допомогою адаптора по шаблону рядка можливістю відмітити рядки
і отримати відмічені рядки. Цікаві методи по загрузці масиву з ресурсів і створення
адаптора з масиву ресурса.
P.S. під час відладки на домашньому компі під віндою ide паде. Цікаво чи це через
баг в коді модуля, чи через саму ide.

_p0441_listsimpleevents_

Доробка до минулого проекту: приклади вішання на ListView обробників скролла, кліка по пункту, і 
відмітки пункту списка (відмітка правда це не відмічення його галочкою, а активація (підсвітка) його
в списку, напр. мош побачити після кліка мишкою клацаючи на клавіші вверх/вниз)

_p0451_expandablelist_

Приклад виводу в дворівневий список (дерево з двома рівнями).

_p0461_expandablelistevents_

Робота з подіями в дворівневому списку. Корисно також приклад відміни події (1С: СтандарнтаяОбработка = Ложь),
Також виокремлення окремого функціоналу з одного класу в інший для спрощення коду (Клас з конструктором,
туди передається контекст основного класу, а далі він формує і віддає аваптер для ExpandableList)).

_p0481_simpleadapter_

Використання SimpleAdapter для виведення данних в список. Виводити в рядок можна в будь-який шаблон
рядка з будь-якою кылькыстю елементів, але виводити можна тільки текст, помітку або картинку (в елементи
які підтримують відповідний тип. Якщо тип не підходить до елемента, виведення в нього не відбувається).
Також якщо в помітку замість булєво передати текст, то цей текст установиться як помітка до флажка.

_p0491_simpleadaptercustom1_
Схоже до попереднього, але тут ми наслідуем класс SimpleAdapter і дешо модифікуєм ого функціонал (
крім заповнення рядків ми ще модифікуєм поля рядків, типу колір, фон, тобто реалізуем умовне оформлення).

_p0501_simpleadaptercustom2_

Робим свій BinderAdapter для того щоб реалізувати свій алгоритм роботи SimpleAdapter, щоб навчити
його працювати з ProgressBar.

_p0511_simpleadapterdata_

Тут добавляння і видалення рядків з списку через адаптер (смисл: редагуєм структуру данних, якою 
ініціалізували адаптер, а потім повідомляем його про зміну данних). Також цікава штука як з пункту 
вибраного контекстсного меню витягнути додаткові дані (через такий адаптер як AdapterContextMenuInfo,
якому годуєм витягнуту з MenuItem MenuInfo)

_p0531_simpecursortreeadapter_

В даному випадку організація виводу дерева з допомогою SimpleCursorTreeAdapter, який використовує дані 
з БД. Особливість в тому що при роботі тре наслідувати класс SimpleCursorTreeAdapter з реалізацією 
метода для отримання курсора дочірнього елемента.

_p0541_customadapter_

Приклад як можна зробити свій адаптер (створенням класса через наслідування BaseAdapter і реалізацію
його авбстрактних методів).
Додатково цікаво передавання даних через Tag View-a. (методи setTag і getTag), при цьому можна передати
як одне, так і кілька значень.
Також цікаве отримання Inflater через: getSystemService(Context.LAYOUT_INFLATER_SERVICE) в контексті
основного додатка ((LayoutInflater) ctx.getSystemService(Context.LAYOUT_INFLATER_SERVICE))

_p0551_headerfooter_

Приклад добавляння шапки і підвала до списку. Особливість: добавити шапку чи підвал можна тільки до 
приєднання адаптора. При цьому адаптор "оборачується" в адаптор з шапкою. Результуючий адаптор містить
дані обгорнутого адаптора з шапками (вірніше шапки з даними обгорнутого адаптора). Що цікаво, данних
підвалу нема, і з результуючого адаптора можна або отримати обгорнутий адаптор, або працювати
з даними результуючого дадптора (які без футерів-підвалів) або видаляти футери-шапки).
На рахунок підвалів це поки шо так я зрозумів.

_p0561_spinner_

Spinner це фактично дропдавн. Одне не до кінця зрозуміло: OnItemSelectedListener реалізує два методи:
при виборі пункта, і коли нічого не вибрано. Не зрозуміло якраз коли викликається другий, о при зникненні
поля виору (напр. при кліку поза ним) він не викликається. Для ЧОго він тоді для спіннера. Можливо
що даний клас ороника використовується не тільки для спіннера, і тут цей другий метод просто ні до чого.

_p0571_gridview_

Використання gridview (типу як список, але не по рядках, а по комірках таблиці: (типу як зменшені
види фоток в файловому менеджері)). Якраз і спроба показати як передогляд фоток реалізувати.
Вилізла цікава штука: якщо загнати віеликі фотки то виникає помилка що додатку нехватає пам'яті і воно 
вилітає. Поки що не знаю з чим це зв'язано. Також приклади як розраховувати кільківсь колонок в гріді (
чи вказувати жорстко, чи вказати ширину колонки і автокількість), а також як розприділити лишній
простір. З чим стикнувся: в методах к-сті колонок і установки способу розприділення є константи
класа GridView. При їх заповненні в параметрах вони всі показані скопом (разом), тобто якщо при встановленні
кількості може бути тільки цифра або константа авторозприділення, то при вводі якавтодоповнення 
з ними відображаються і константи використання вільного простору, указання яких не викликає помилок, 
але дає нам не зовсім адекватний результат.

_p0581_timepickerdialog_

Вивід діалогу з вибором часу.
Через ShowDialog/OnDialogCreate, на даний момент вони показані як застарілі (deprecated). Тут і далі
вони використовуться.

_p0591_datepickerdialog_

Аналогічно до попереднього, тільки осоливість: місяць вказується через індекс (січень як 0 а грудень як 11)

_p0601_simplealertdialog_

Діалог з 3-ма кнопками (максимум) типу так/ні/відміна. Для генерації діалогу використано AlertDialog.Builder
Не знаю чому, але кнопки вистроїлися зліва направо (навпаки). Пробував, порядок виклику методів установки
кнопок не впливає на це.

_p0611_alertdialogprepare_

В уроках писало що onCreateDialog  виконуэться тыльки раз при першому выдкритті діалога. А далі 
перед кожним показом виконується тільки onPrepareDialog (де можна з діалогом щось робити, окрім
керуванням виидиміст його елементів, яке конфігурується при створенні). В мене в реалі onCreateDialog
виконалось при старті програми.

_p0621_alertdialogitems_ 

В даном випадку приклад як можна виводити список в тіло діалогу (по пунктах). Зроблено трьома прикладами: 
через адаптер, через курсор, або прямою передаче списка пунктів (ListArray).

_p0631_alertdialogitemsingle_

Реалізація діалогу з списком вибору (тільки одного пункта). Виводиться дані в список через курсор, але
можна це робити так як і в попередньому прикладі, через адаптер або список.

_p0641_alertdialogitemsmulti_
Реалізація діалогу з списком вибору, Але вже з можливістю вибор кількох пунктів зі списку.

_p0651_alertdialogcustom_
Приклад як можна для діалога призначати свій View і відповідно опервати ним. В даному випадку редагування
своїх же рядків в AlertDialog

_p0661_alertdialogoprations_

Робота з подіями діалогу, також і управління ним з допомогою його методів.
Також можна ним управляти з Activity. При цьому при showDialog сам діалог по ідентифікатору зв'язуєтся
з Activity і ми можем з Activity взаємодіяти зі зв'язаним діалогом (показувати і ховати його, або відв'язати
його від Activity. Проте я думаю зараз це неактуально через те що ільшість цих методів на даний момент застарілі.

_p0671_processdialog_
Показ діалога з прогресом виконання: два вида, горизонтальна (також і з другорядним прогрессом), абол кругова
безкінечна. В даному прикладі відкривається не з-під Activity, а просто конструктором. Такшо ніц не мішає
робити так. Цей діалог також позначений застарілим.
Класний приклад як використовувати Handler.

_p0681_parcel_

Приклади роботи з об'єктом parcel. По своїй суті це контейнер, куди можна записувати набір значень різних
типів. При цьому в середині об'єкта вони тип перетворюються в байти (к-сть байт залежить від типу значення),
і приклеюються один до одного. При цьому зсовується курсор (це типу виборка байт, при запису в яку
значення перетворюються в байти і запихаються туда)). По ній можна позиціонуватися побайтно і вибирати 
який тре тип. Відповідно якщо ми будем знати на якій позиції починається який тип, ми при читанні можем
зпозиціонуватись і прочитати його. Ящо не вгадаємо позицію поатку значення або його тип, то на виході оримається
каша. Також ми можемо отримати байтову послідовність контейнера (метод marshall()).
В довідці наголошують, що його використовувати як серілізатор немош, а його розробили для передачі
через високошвидкісні канали IPC.

_p0691_parcelable_

Переробка користувацького класа для інтерфейса Parcelable: коли нам з ынтента треба передати не простий тип,
а об'єкт, то шоб його дати в putExtra(), треба щоб в ньому був реалізований інтерфейс Parcelable. 
Я так зрозумів, що це щось наподобі Serializable (і через нього це тоже можна зробити), але він "лугший", 
і для андроїда рекомендують використовувати саме його. При цьому в класі, який виконує інтерфейс, ми якраз
в двої місцях описуєм, як об'єкт класа упаковувати в Parcel, і як з нього нам конструювати об'єкт на виході.

Висновок: тре тянути і згадвати JAVA, а то я код дуже поверхнево зрозумів.

_p0701_saveinstancestate_

При, наприклад, повороты орієнтації екрану, Activity знищується, а замысть нього тим самим кодом створюється 
інший екземпляр цього Activity. При цьому весь код ініціалізується заново. Проте в SDK зроблено так,
що якщо View-елементи мали присвоєні id, то вони відновлюють свый стан (напр. поле вводу зберыгаэ введений
текст.). На інші випадки пропонується використовувати події onSaveInstanceState() і onRestoreInstanceState(),
в якому і потрібно прописати код зереження/відновлення стану. 
Якщо потрібно зберегти ссылку на об'єкт в пам'яті, то щоб при дестрої/створенні Activity його не підчистили,
можна користуватись такими речами як onRetainNonConfigurationInstance/getLastNonConfigurationInstance.

_p0711_preferencessimple_

В попередньому уроці (десь 30-ті), ми зберігали прості дані по ключу в хранилище SharedPreferences (
воно там зберыгаэться як в бд, тыльки по принципу ключ/значення). Так ось можна створити ресурс з тегом
в ньому типу <PreferenceScreen>, де описати вигляд єлементів цих настроєк, а потім в окремому класі
(class PreferencesActivity extends PreferenceActivity) можна його догрузити з ресурсів. При  цьому при
відкритті цього Activity автоматом елементи на ньому зв'яжуться по ключах з ресурсів з значеннями із
SharedPreferences. Без коду при їх реидагуванні вони відразу зберігаються в SharedPreferences.
Так з мінімум коду можна створити строінку настроєк аплікухи.
_P.S. Правда метод загрузки даних з файла ресурсу на даний момент позначений застарілим._

_p0721_preferencessimple2_

Приклад як просто маніпулюючи з тегами в файлі ресурсів з PreferenceScreen можна організувати діалог
вибору зі списку (парами масивів, де в першому зберігаються значення пунктів, в другому відповідні їм
користувацькі представлення). Такж маніпуляціями можна організувати ієрархію вікон настройок, і групувати
пункти настройок по категоріям.
НЕ ЗАБУВАТИ доавляти новий актівіті PreferenceScreen в маніфест, ато забуваю і не розумію що твориться.

_p0731_preferencesenable_

Приклад як ще в тегах ресурса налаштувань можна робити активність одних пунктів від стан чекбоксів 
 інших (активність по умові). При цьому треба пам'ятати що це не діє на категорії (активність категорій,
 а вірніше їх вмісту, тре накодити руцями в коді, а не просто сконфігурувати в ресурсі). Також можна
 ресурсом керувати активеністю переходу на вложені екрани. Аналогічно можна вказати пояснення по
 включаючих активність чекбоксів окремо для включеного і виключеного станів (summaryOn i summaryOff).
 (_Відмітка що використаний в коді findPreference також застарілий_)
 
 _p0741_preferencescode_
 
 Той самий приклад, але тільки всі елементи актівіті настроєк кнструюються кодом (а не грузяться з xml),
 правда метод встановлення PreferenceScreen також вже застарілий.
 Є один момент: встановлювати Dependency для налаштувань (тобто від якої настройки залежить поточна),
 бажано в кінці (ну як мінімум не раніше від того як до екрану будуть приєднані як поточна настройка, так
 і та від якої все залежить, бо інакше виникала помилка що залежної настройки не знайдено).
 
 _p0751_files_
 
 Робота з читанням/записом файлів. Все як в звичайній JAVA. Особливість тільки в кількох методах по
 отриманню стандартних шляхів для Android (до сд-шки, і т.д.). Також прописати дозвіл до доступу до
 microSD на запис, інакше будуть сипатись помилки, при чому типу шо "Файла не існує". А ті методи які
 записують і вертають результат (типу file.createFile()) вертає просто ложь, шо просто ніц не створено.
 
 _p0761_tab_
 
 Панель з табами. По ходув коментах почитав що то вже застаріле, і гугл ренкомендує робити то по іншому.
 Воно по ходу вже і до кінця працює: іконку заставити показуватись мені не получилось: одні пишуть що на деяких 
 старих темах вонео працюе (Black), хоча я та і не зміг заставити під такою темою запахать, а інші пишуть
 що іконки відображаються в такому методі тільки на старих андроїдах (до 3-ї версії).
 
 UPD Тему получилось поміняти на Black (прописав не в маніфесті, а в тезі основного LinearLayout-а 
 головної сторінки), картинка появилась. Правда тупо виглядає, мабуть дійсно це все вже застаріло.
 
 _p0771_tabintent_
 
 Якщо головне Activity наслідувати від (TabActivity), то TabHost можна отримати через метод getTabHost,
 при цьому зразу ініціалізується самі таби, а далі просто встановлюєм інші Activity в контенти табів.
 При цьому в них треба використовувати Activity (бо якщо в них вид AppCompatActivity, то під табами
 відобразиться шапка, що неправильно виглядає, і забрати її якось по іншому не мош). Тож видно що TabActivity
 застаріла, і адрекватно відображається зі старими класами Activity, а зі новими не хоче. 
 
 _p0781_tabcontentfactory_
 
 В контент таба можна додавати окрім іншого Activity, айдышок елементів, які мають стати контентом, 
 можна передати TabHost.TabContentFactory. При цьому треба доробити метод OnCreate, який би по по вхідному
 тегу рулив яку вкладку йому треба вернути (а її можна із View нафігачити чи кодом, чи через 
 LayoutInflater). А от тегами э теги, якы ми кидали в конструктори вкладок TabSpec (він тегом і 
 буде дьоргати TabContentFactory). Жаль тільки що TabActivity застаріла.
 
_p0891_xmlpullparser_

Парсер, який поступово проходить те за тегом (виборка), дерево обходить по вітці. При цьому кожного разу
курсор приймає тип початок тегу, текст, кінець тегу (на початку початок документу, в кінці кінець документу)ю
Для тега є така штука як колекція атрибутів, глибина (в типі Початок тегу), вміст тегу (текстовий).
Конструктов: через getResources(...).getXml, якщо тре прочитати з ресурсів, або через клас-фабрику, якщо
з текстового файлу.

_p0801_handler_

По ходу хендлери - це об'єкти, які при запуску дозволяють приймати повідомлення (з шини) і обробляти їх
(вішати обробники подій на них). При цьому в шину можна кидати будь-яку кількість мессажів, при чому хитрожопих (які 
спрацьомують, тобто оробляються в хендлері, наприклад, в певний час).
В даному прикладі хендлер використовується для взіємодій процесу запущеного в іншому потоці з основним потоком.
Зроблено це тому, що якщо напр. загрузку файлів запустити в основному потоці, він буде стопатись (завмирати на час скачування),
а так створиться інший потік, який буде після загрузки кожного з файлів кидати мессадж, а він в основному
потоці буде обролятися хендлером). Також причиною того що використовується хендлер є те, що створювані 
нові потоки не мають доступу до елементів інтерфейсу, тому не можна напряму з другорядного потоку
міняти вигляд форм.

_p0811_handlersimplemessage_

Інший приклад використання Handler для організації простої взаємодії між потоками.

_p0821_handleradvmessage)_

Передача складніших данніих через Message (крім that можна передати два параметра типу int і один Object).
На відміну від sendEmptyMessage (який меседж створює і зразу надсилає), треба спочатку створити меседж,
а потім самому його надіслати. При цьому рекомендується створювати його не конструктором, а методом
obtainMessage самого хендлера (що нібито є продуктивнішим).

_p0831_handlermessagemanage_

Приклад як можна закинути месседж в обробку з затримкою: одним методом по часу від закдування, по іншому 
від часу з моменту запуску аплікухи (якщо цей час вже пройшов, то все обробиться зразу, без затримки).
Також з черги по ыдентифікатору that можна видаляти невиконані месседжі з черги (з одинаковим that месседжі
видалються одним запросом). Також можна видаляти і по комбінації that i obj.
Також сам обробник можна конструктити в виды об'єкта і передавати його на вхід конструктора Handler

_p0841_handlerrunnable_

З допомогою методів post (напр. post, postDelayer...) мт можем кидати в чергу до запуску об'єкти з 
інтерфейсом Runnable, які при настанні обробки в черзі і будуть запущені. Прикольна можливість.

_p0851_runnableuithread_

Тут приклад як можна запускати о ообробку Runnable без явного використання handle. Ці методи поставляються
самим андроїдом. Два зразу кидають в чергу, один в чергу з затримкою на спрацювання.

_p0861_asynctask_

Є також такий клас як AsyncTask. Він є обгорткою над handle-ом. По факту программер наслідуючи його
реалізує (обов'язково) метод який і робить всю роботу в паралельному потоці, а також при необхідності
інші методи (які викликаються як події об'єкту класу, напр. перед стартом, після виконання). При цьому 
об'єкти класу можна стартанути тільки з головного Гуі-потоку і тільки раз.

_p0871_asynctaskparams_

Розширення попереднього прикладу: при оприділенні субкласу (AsyncTask) ми в кутових дужках вказали 
три войда (типу пусті значення). Так ось, в першому вказується тип вхідних параметрів, в другому тип 
проміжних (прогресса) параметрів, в треьому - результатів. Покищо треті не використовували. Ще момент, якщо
вказати тип типу напр. "String ...", це типу массив значень стрінгів. Далі методом execute ми можемо
в якості параметрів вказати будь-яку кількість параметрів типу стрінг, які передадутся в doInBackground.
Далі в doInBackground ми можемо викликати метод postProgress аналогічно до execute, який викличе виконня
методу класу onProgressUpdate, але він вже виконається в UI-потоці з відповідними переданими параметрами.
Так ми запустим другий потік і отримаємо прогрес його виконання в головний потік.

_p0881_asynctaskresult_

Третім типом параметра при написанні еласа вказуєм тип результату. Саметакого типу і повинен вертати наш 
реалізований в класі метод doInBackground. При цьому це значеннями отримаємо в "події" onPostExecute.
Також ми його можем отримати методом get нашого класу в головному потоці, от тілки якщо  другорядні
потоки ще не викликали цей метод блокує виконання головного потоку до виконання другорядних і вертає результат.
Можна визвати цей метод з параметром таймауту. Тоді він блокуватиме не довше таймауту і якщо процес не 
завершиться до таймауту то викличе Виключення (але самі запущені AtyncTask продовжат виконуватись).

_p0891_asynctaskcancel_

Це приклад переривання асинхронних подій. В головному потоці визиваєм метод cancel (з параметром типу
булєво, чи потрібно системі перервати потік, чи чекати його виконання). При цьому рекомендується по 
пририванні потоку не надіятись на систему, а в виконваном дргорядному потоці періодично викликати 
метод "isCanceled", який якщо верне признак чи необхідно нам самим перевати потік, що кодом і робиться.
При цьому (перериванні) в головному потоці спрацює "подія" onCancelled, а onPostExecute ніколи не спрацює.
Якщо потік завершив свою робот ще до переривання, або його немож з якихось причин перервати, то визваний
метод cancel в головному потоці верне false, а при спышному перериванні true.

_p0901_asynctaskstatus_

Також можнаметодом getStatus взнати статус асинхронної задачіЖ може бти запланованим/в процесі/завершеним.
Проте э нюанси: пишуть якщо скасувати задачу ще до її старту, то статус буде все-одно запланованим.
По моїм експерементам при будь-якому скасуванні задача переходить в статус виконаної. Проте що там, що там
відрізнити виконану чи заплановану (кому шо і в яких випадках потрібно) можна методом isCancled (розглядався
в попередньому прикладі).
 
_p0911_asynctaskrotate_ 

Тут вже поэднання специфіки андроїда і асинхронних задач. В попередніх прикладах задачі ми зроили внтрішнім
класом, тому при повороті екрану в нас перествориться актівіті, а так як задача в нас з ним також
перествориться, то перествориться і запуститься друга аналогічна асинхронна задача (причому перша, 
хоч актівіті і пропав, в пам'яті лишиться і продовжить свою роботу). В даному прикладі проують суміщенням
70-го урока пр повороті перез знищеннями одногоактівіті зберегти асинхронну задачу, а при створенні 
нового знову створити її. Правда цього мало, так як асинхронна задача (об'єкт класу) зв'язано з першим
актівіті (так як це вложений клас), тому тт вирішили при реалізації класу асинхронної задачі зробити
його статичним, і кодом в класі вручну реалізувати зв'язок йього статичного коласа задачі з конкретним
актівіті.
Правда щоб цього не роити мош просто реалізувати клас фонової задачі не внутрішнім класом, а "збоку"
від актівіті.
P.S. В даному прикладі для відтворення задачі використовується реалізація методу 
onRetainNonConfigurationInstance, який в нас непрацював через те що в якості актівіті використовувався
android.support.v7.app.AppCompatActivity. Том я поки переправив його на android.app.Activity. Варто
для практики розібратись з цим і зробити через android.support.v7.app.AppCompatActivity (як в 70-му прикладі)

_p0921_ServiceSimple_

Я так зрозумів що сервіс, це як Актівіті, тільки без GUI, він існує на протязі життя додатку (а не 
тільки на час видимості інтерфейсу). Також інтересно що в ньому кож також рекомендують виносити в інші
потоки (а не виконувати прямо в його потоці). Такоє має події onCreate, onStartCommand, onDestroy. При 
цьому перші два виконуються тільки раз на час життя процесу, а onStartCommand може виконуватись кілька раз 
(напр в нашому прикладі якщо нажати ще раз старт ще до закінчення минулого сервісу, то onCreate і onDestroy
не удуть ще раз виконуватись, а виконається тільки onStartCommand і нагрузка цього методу). А от якщо 
нажати старт після дестроя, то все почнеться по колу.

_p0931_servicestop_

По ходу так і є, після створення сервіс приймає задачі, кожному старту задачі присвоюєтьтся свій ідентифікатор.
Коли у всіх буде виконано метод stopSelf (повідомлення про те що задача в сервісі виконана), то сервіс
буде ліквідовано. Якщо виконано stopSelfResult, він верне ще і резльтат, чи загалом сервіс зупинено.
Що в прикладі цікаво, це те що використовується такий клас як Executor, який створюэ чергу виконання
об'єктів runnable (вірніше організовує фіксований пул потоків, які виконують задачі поступово). Також
и створили об'єкт, який по факту доступний на протязі існування сервіса (від onCreate до onDestroy для
всых запущених задач).

_p0941_servicekillclient_ - _p0942_servicekillservice_
 
Демонстрація того як сервіси обробляють своє переривання. При своїй реалізації onStartCommand можна там
вернути одну з трьх констант, яка вплине на поведінку сервіса після переривання (як правило системою
при нестачі ресурсів). Якщо вернемо константу NOT_STICKY (якось так), то при наступному зверненні до
сервіса він собі стартане як нічого не бувало. Якщо вернем STICKY, то він при першії же нагоді буде перезапущений,
при цьому в флагах, переданих в onStartCommand буде видно що він запущений рестартом, але тіко раз, спочатку,
і з інтентом в виді null (тільки раз і з одною ід, незалежно в якому стані його перервали). Також є 
і режим RESTART_INTENT_REDELIVERY. В цьому випадку система спробуэ перезапустити сервіс, але на вхід
знову подасть тої же інтент і вному ж стані, який був поданий стопнутому процесу. При цьому якщо його
перервали з кількома незакінченими стартами, то відповідно всі вони (з відповідними ід і інтентами) буде
рестартовано.

_p0951_servicebackpendingintent_

Приклад як можна вернути результат з сервіса в актівіті, який його запустив, з допомогою pendingIntent.
Коли в сервісі виконається метод pendingIntent.send, в актівіті виконується метод onActivityResult з
цими даними. В даному випадку я для трьох сервісів використав один pendingIntent. В результаті в мене
все підвисло на час виконання всіх сервісів, а після їх всіх виконання відразу вернулись 3 результата.
Якщо б я їх створив тоже 3, то вони б повертались поступово для кожного сервіса окремо.

_p0961_servicebackpendingintent_

То саме тыльки через BroadcastReceiver, тіко ця штука працює навпаки: в актівіті створюєм його і реєструєм
його на прослуовування певного IntentFilter, а далі там, звідки треа послати мессадж, по URL створюєм
Intent, в нього пхаєм необідні для передавання дані, і методом sendBroadcast шлем його. Там де ми 
екстендили клас BroadcastReceiver (в актівіті) виконається реалізований нами метод onReceive. По ходу цей
метод правельніший за попередній.

Мля, та сама тема з виконанням потоків що і в попередньому прикладі.
По опису урока такого не має бути, тре буде перевірити.
!Всьо добре! В даному прикладі для виконання процесів використали Executor, якому треба просто передати
процес (я я просто його ще і стартував (після Execute виконав ще і Runnable.run)), а в попередньому
приклады все виконалось та, бо ми стартували одночасно три потока з однаковим часом виконання. Тому все

_p0971_servicebackpendingintent_
Приклад як можна підключатись до сервісу (bindService, unbindService). При цьому в запущеному сервісі
спрацюють відоповідні "події". Також після того як сервіс підключено в об'єкті ServiceConnection 
з допомогою якого робився конект з Актівіті (з ініціатора) виконається ще подія після конекту
onServiceConnected. А от disconnected виконаэться тільки в разі коли з'єднання розірвано не з
ініціативи його ініціатора (напр. примусово, при цьому система через деякий час знову запустить його 
 автоматом), а в разі унбіндінга - воно не виконається. 
Також при конекті вказується флаг режиму конекту, і якщо вказати BIND_AUTO_CREATE, то в разі відсутності
 запущеного сервісу він автоматично запуститься, а після унбіндінга він спробує відключитись.
 Якщо ж сервіс був запущений, то після унбіндінга він і залишеться запущений. Якщо було кілька 
 біндінгів до сервіса, то він лишиться живим поки вони всі не відключаться. 
В сервісі в події onUnbind треба вернути булєво. По вмовчуванню вертається Ложь. При цьому якщо
в межах існування сервіса пройде другий раз бандінг, то все буде як звичайно, а якщо вернути
Истину, то при слідуючому біндінгу після того, від якого від'єднуємся, при старті замість 
onBind виконається onRebind.

_p0981_servicelocalbinding_
В даному випадку приклад як можна заставити взаэмодіяти актівіті з сервісом (актівіті може виконувати
експортні методи сервіса, та інше). В даному випадку все виконається в одному спільному потоці (актівіті
біндиться до сервіса, а той віддає актівіті розширений об'єкт біндера, в якому є метод по віддачі
самого актвіті. За допомогою цого методами і отримуєм доступ до сервіса, тобто ссилку на нього, в
самому актівіті). Момент: для приклада ми в сервісі використали таймер, який первідично виконує
таймертаск. Так от, для зміни періоду циклу я перестворював ці об'єкти, а по вакту достатньо було
перестворити тільки таймертаск, а сам таймер можна було не чіпати. При цьому зупиняти заплановану 
задачу треба методом Cancel самого таймертаска (а я таким методом таймера робив).

_p0981_servicenotification_
В цьому випадку приклад як можна з сервіса взаємодіяти з актівіті за допомогою Notification (з допомогою
нього в шторку можна кинути меседж, при натисканны на який можна запустити настроэний актівіті і яерез
PendinIntent передати туди якісь параметри).
Приклад з уроку застарів, його не то шоб позначили застарілим, а викинули з API. Тому зараз для створення
об'єкта Notification рекомендують використовувати Notification.Builder, що і було зроблено.

_p1000_ Полєзності сервісів
1. IntentService - розширює клас Service, а саме в ньому тре реалізувати метод onHandleIntent, якому
всі інтенти переадресовується з onStartCommand, проте вони відразу виконуются в окремому потоці.
Для використання в Android 8 і вище ввели деякі обмження і реклмендують використовувати дещо інше.
2. В сервіся є методи startForeground і stopForegraund, перший з якого вереводить сервыс в режим
коли він не може бути закритий системою напр. при нестачі пам'яті, другий метод виводить його з цього
режиму. При цьому в шторці виводиться незакриваєме повідомлення (в метод передається Message).
3. Як запустити шось на автозагрузку: тре створити прожект з BroadcastReciever-ом, налаштованим на
системний інтентфільтр з екшеном "android.intent.action.BOOT_COMPLETED", при цьому повинні бути 
права android.permission.RECEIVE_BOOT_COMPLETED. Тоді він буде запущений при старті системи, а вже
з нього можна стартанути якийсь сервіс.

_p1010_ Контент провайдер
Реалізація контент-провайдера. Це напр. проект, який реалізує зберігання і видачу данних, до якого 
можна під'єднатись ззовні і з допомогою спец. сформованого URL кинути запрос на отримання/модифікацію
данних напр. в БД. З боку клієнта необхідно з допомогою об'єкта ContentResolver сформувати підключення і 
з допомого вормування спец URL використовувати сервіси провайдера, а з боку сервера написати свою
реалізацію класу ContentProvider, який обробляє запроси по цих URL.

_p1020_ Обробка події тача
Схоже на onClickListener. onTouchListener має параметр, в якому знаходиться об'єкт, яерез який вже можна
отримати дані події (вид події, нарп. нажимання, відпускання, рух вказівника, координати вказівника)

_p1030_ Робота з мультитачем
Дещо інакше отриуються дані для обробки з мультитачем. Там необхідно отримати індекс і ідентифікатор
нажаття (індекс - це індекс в колекції активних нажимань, а ідентифікатор для коного нового нажимання
збільшеється на 1). Також цікава робота з Switch в даному випадку. Та немає брейків в деяких місцях і
я не зрозумів як воно працює.Додатково я не зміг побачити під відладкою: не було телефону 

_p1040_ Фрагменти
Фрагменти - це по факту вложені актівіті. В даному прикладі можна побачити як вони працюють. Життєвий
цикл в них майже такий самий як і в актівіті, практино ті ж події

_p1050_ Динамічна робота з фрагментами
Приклад як мона кодом маніпулювати фрагментами в Актівіті. Можна це робити з допомогою класу Transaction
manager. Це ты самі транзакції: відкриваємо її, добавляєм дії (добавляєм/забираєм/заміняєм) врагменти,
а далі після комітуці діїприміняються (на екрані). Все це можна добавляти тільки в контейнер типу
ViewGroup всередині актівіті.Також можна добавляти ці транзакції в чергу Backstack. І тоді із цієї
черги в зворотньому порядку по нажиманню кнопки назад ці транзакції будуть відкатуватись.
`Також особливість: при добавлянні фрагмента в проек із шаблону екстендиться клас Fragment з пакету,
несумысного із застосованим TransactionManager. Цей новий клас із шаблона скорше всього із нового SDK.`

_p1061_ Взаємодія із елементами фрагментів
Все робиться через Activity, тобто з нього (аctivity) через менеджер фрагментів ми можем дьорнути сам
 фрагмент і зробити з ним те що треба. Якщо треба організвати зворотню взаємодію, то оргнаізовуєм 
 це через події. В даному прикладі в фрагменті з допомогою Інтерфейса організовуем Лістенер, а в актівіті
 ми реалізовуєм його. Таким чином фрагмент генерить подію, а актівіті ловить її і обробляє. Навіть якщо
 треба щоб один фрагмент щось зробив з іншим, то все одно дьоргаєм актівіті, а той з іншим фрагментом 
 робить то що треба.
 
_p1071_ ActionBar
Все по анології як з менюшкою налаштувань, яка інфлейтиться з xml, тільки xml має бути певної структури,
через неї і іконки, і текст пункта, і вигляд (тип іконка + текст, чи просто іконка, чи що) конфігуюється.
От тільки в залежності від того чи ви використовуюєте Activity, чи AppCompatActivity, треба відповідно
її підкорегувати, щоб вона вірно відображалать. Також можна в менюшку добавити іконку назад. Для того
щоб іконка відображалась (при використанні AppCompatActivity) треба або використовувати setDisplayHomeAsUpEnabled()
в поєднанні з setDisplayShowHomeEnabled, або використовувати setHomeButtonEnabled (але іконка появиться
тільки коли вказано android:parentActivityName).
Ще кілько корисних методів: setTitle, setSubtitle, setDisplayShowTitleEnabled

_p1081_ ActionBarNavigation
Приклад як екшенбар можна використовувати для навігації в аплікусі: або табами, або випадаючим списком.
Правда дані методи зараз застарілі, пропонується використовувати іншу філософію проектвання для навігації.
Також можливо до табів або списків добавляти елементи, які описані в попередньому прикладі, а з 4.1 
можна екшенбар при нестачі місця ділити на дві частини: все що не влізається в вершню частину екрану
показується в нижній частині екрану (для цього в маніфесті актівіті в атрибуті uiOptions 
вказати splitActionBarWhenNarrow).

_p1091_ ListFragment
Використання фрагментів для реалізації списку. Даний клас при наявності в адаптері списку показує
фрагмент із списком, якщо немає - то фрагмент який показує що список пустий. При цьому місця цих гогтових
фрагментів ставляться в лайаут ListFragment шляхом вказання предопреділених айдішок.
Вказуючи ресурси строк з чекбоксом або радіобатоном а також вказавши елементу лістсписку (через getListView())
і вказавши відповідний режим вибору списку, також підчипивши лістенер, можна зробити таке як в уроках
43, а лістенер як в 44. Також цікаво виглядає android.R.layout.simple_list_item_activated_1.

_p1101_ DialogFragment
Приклад як використовувати фрагмент типу діалог, це фрагмент, який має події AlertDialog. (на мою думку).
Також не потрыбно путати актівіті і фрфгменти з їх support-аналогами. По прикладу один діалог створили
з допомого класичного варіанта (layout-file), другий з допомогою Dialog-builder (виглядає красивіше). 
Приклад використання DialogBuilder і інші приколи з ним можна подивитись в прикладах з 60- і дальше, 
ті речі можна робити і в нашому випадку

_p1111_ PreferenceFragment
По аналогії як в 71-75 прикладах реалізовано вікно настройок через похідну фрагмента (там це було наслідування
PreferenceActivity, а тут PreferenceFragment, але по суті вони мать однакову функціональність).
Також можна організувати закладки (як в 72, тільки виглядає воно цікавіше).
І тут приколи з сумісністю: до кіт-ката по дефолту isValidFragment в PreferenceActivity вертала Истину,
а зара викидає виключення, тож пришлось додатково його преропреділити.

_p1121_ DinamicActionBar
В даному прикладі показано як можна динамічно редагувати пунктами меню ActionBara і їх видимістю. 
Але більше цікаво як можна інтегрувати свої пункти в ActionBar Activity з фрагмента: при цьому фрагмент
при відображенні в Activity добавляє свої пункти меню, а при забиранні звідта забирає свої менюшки.

_p1131_ ActionMode 
Приклад реалізації альтернативи контекстного меню використанням ActionMode. При цьому можна його
відкривати вручну, або вішати відкриття по довгому кліку по пункту. В самому об'єкті є обробники подій
нажимання на пункти, як події на створення меню, знищення меню.

_p1141_SupportLibrary
В ньому і розказується про сумісність: бібліотеки типу Support. Смисл всієї басні - ці бібліотеки мають
аналоги плюшок які добавили в нові версії для старих версій андроїда (напр. Фрагменти появились з 
4-го андроїда, але з допомогою цих бібліотек їх стало можна використовувати і в старіших версіях.

_p1151_MultipleScreen
Приклад яв використовувати быльшысть всього що було до цього в купі: приклад екрану де з одної сторони
знаходиться список з пунктами, а з іншої розшофровки пунктів. При нажиманні на пункт списку в іншій
панельці відкривається розшифровка списку. При цьому в горизонтальній орієнтації видно тільки список і
при нажиманні відкривається розшифровка, а в горизонтальній екран ділиться пополам: справа розшифровка,
зліва список. Робиться це зв'язкою двох актівіті і двох фрагментів. Цікава в фрагментах така штука як
аргументи: їх можна добавляти до об'єкта фрагмента скільки хоч штук, і навіть при перестворенні
фрагмента (напр. при зміні орієнтації) фрагмент збереже свої аргументи (це можна побачити в статичному
методі в фрагменті, де виконуєтсья дефолтний конструктор і додаються аргументи.)

p1161_mngtasks
Всі апліухи запускаться в рамках тасків. Якщо викликаються актівіті, то вони вяжуться до тасків. При 
цьому є різні режими відкриття (в залежності від відкритих вже актівіті в рамках таску і його положення
в стектрейсі таска відкриваєме актівіті може по різному поводитись, а саме створюватись новий екземпляр
його актівіті чи відкриватися існуючий, відкривающий актівіті може переміститись в корінь стектрейсу, 
і може модифікуватись сам стектрейс). Режими відкриття актівіті можна вказати через launchMode в маніфесті
для конкретних актівіті (їх всього 4), або вказуватися через флаги Intent-ів, які викорриистовуються
для відкриття інших актівіті. При цьому флаги мають вищий приорітет і їх більше (різних режимів). 
Правда даний урок трохи застарілий. До Lolilup поведынка як описана, а починаючи з неї ужесточили 
допуски, і аплікуха не має доступу до інших процесів. І тому процес не може тянути на себе актівіті
процесів інших аплікух, і в якщо таке відбувається то або сворюється новий процес іншої аплікухи
з передачею їй управління, або відкриваєтья потрібна актівіті в існуючому процесі іншої аплікухи з
передачею їй управління. І ця особливість (ізоляції процесів різних аплікух) характерна для всіх
режимів відкриття.

p1171_SimpleWidgets
Приклад віджета. Для його роботи треба оформити xml-layout файл, наслыдувати клас AppWidgetProvider, 
і з допомогою XML-файла метаданних пыдцепити їх яв віджет. Також трохи підмастирити маніфест (звернути увагу
на екшен, який також вказує що це віджет). Цикл: при першомудобавлянні: onCreate, далі періодично
для всіх екземплярів onUpdate. Для кожного видалення выджета з екрана: onDelete,  а після видалення
останнього ще і onDisabled.

p1181_CustomWidgets
То саме, але приклад розширений тим що при добавлянні на екран відкривається вікно конфігурування екземпляру
віджета. Тож добавляем актівіті, який зерігає конфіг в SharedPreferences (в назвах настройок, тобто ключах,
використовуємо ід екземплярів віджетів для їх відрізняння один від одного). При цьому в метаданих і в Action
актівіті прописуємо що актівіті є конфігураційним, і воно автоматом запуститься при добавлянні екземпляру
віджету. Нюанси: 1. Після закриття конфігурації віджету його оновлення не відбвається, тож треб накодити
його примусове оновлення. При видаленні віджету треба накодити відповідно видалення настройок, а при додаванні,
кофігурувати його якщо є з яких настройок. Прямого доступу до елементів в layout выджета нема, то ж 
для доступу до них користуємося наявними для цого методами AppWidgetManager, як ним користуємось для 
примусового оновлення з актівіті.

p1191_PendingIntent
Вроді вже стикались, але все одно: PendingIntent можна створювати на базі звичайних інтентів, а далі
з його допомогою створювати мессаджі PendingIntent.getBroadcast. Далі з цього об'єкта створювати
Message (в нових андроїдах через Message.Builder), і якщо їх послати, по вони появляться в штрорцы повыдомлень,
а по нажиманню на них клас що наслідує BroadcastReceiver і настроєний в маніфесті отримає месседж (виконається onReceive) з Intent, який використовувався 
 для створення PendingIntent. 
При створенні двох PendingIntent якщо використовувались ідентичні інтент (ті, які мають однакові
data, action), то вони обидва матимуть один один і той же інтент (тобто при створенні другого PendingIntent
система побаить що такий інтент вже був в першому разі і підставить його замість другого екземпляра
схожого intent). Поведінкою системи при створенні PendingIntent із схожих Intent можна управляти 
через указання при отриманні об'єка броадкаста (PendingIntent.getBroadcast) флага поведінки при 
 наявності схожих Intent. Розділити два інтенти можна вказавши різні Action, або засунувшт в них
 різні дані в Data (setData). Це не можливо, то вказавши при створенні броадкастів різні requestCode
 і тоді навіть схожі Intent будуть рознесены по своъх PendingIntent.
Самі ці PendingIntent в системі прив'язуються до аплікухи і не втрачаються ні від вбивання процесу,
ні від перезагрузки. Але втрачаються при переустановці системи.
Також є така штука як AlarmManager, з допомогою якого можна запускати PendingIntent по розписанню. 
Розписання може бути двох видів: в мілісекундах від загрузки системи, і відносно системного часу 
(System.currentTimeMillis). Також ці два вида можуть бути і з суфіксом _WAKEUP, який означатиме що
при спрацюванні вони виведуть пристрій зі режиму сна). Якщо запустити це через метод set, то воно
спрацює раз, якщо через setRepeating, то спрацьовуватиме багато раз через вказаний період, а виконання
можна перервати методом AlarmManager.cancel

p1201_ClickWidget
Обробка кліків по нажиманню на елементи віджета. Для ініцілізації цього всього в onCreate з допомогою
onUpdate створюєм необхідні pendingIntent для запуску по нажиманню на кнопки і прив'язуєм їх до кнопок
 (з допомогою RemoteViews.setOnClickPendingIntent). Ці інтенти можна настроїти на виконання коду з цього
 ж класу AppWidgetProvider через реалізацію в ньому методу onReceive (так як він є наслідником BroadcastReceiver-a).
 Але обов'язково в реалізації виконуєм такий же метод ссуперкласса, інакше "поламається" оновлення
 самого AppWidgetProvider
 
p1211_ListWidget
Реалізація списку віджета: для цього додатково наслідувати два класа - RemoteViewService.RemoteViewsfactory
(вона якраз є фабрикою пунктів списку, так тре рефлізувати кілька методів) - сам RemoteViewService (
в якому якраз проводиться створення об'єкта RemoteViewsfactory при переопреділенні onGetViewFactory).
В самому віджеті в onUpdate потрыбно створити intent з action налаштованим на наш RemoteViewService.
При цьому якщо не рознести ці інтенти через призначення їм різних data, то для кожного з екземплярів
віджета інтенти будуть однаковим і вони всі отримають одну і ту ж фабрику (список продублюється), то ж
призначим їм різні data, щоб в кожному з них був свій список.
 Для реалізаціїреакції на нажимання на пункти меню використовуємо звичайні Broadcast: просто коли
 створюєм бродкаст - то створюємо шаблонній PendingIntent (RemoteViews.setPendingIntentTemplate). 
 Далі в RemoteViefFactory для кожного з пунктів (в методі getViewAt) ствоюєм свої інтенти, якими 
 передаємо всі необхідні для обробки дані.При нажиманні на пункт меню шаблонний PendingIntent доповнюэ
 свій інтент даними з інтента меню, і вже в самому віджеті в onReceive ми можемо ловити і обробити
 інтент с акшеном із шаблонного інтента (акшен нажаття на пункт) і з данними нажатого пункту.
 
p1221_WidgetExtras
Деякі плюшки: через паарметри в метаданих можна добавити прев'юшку до віджета (картинку кидати в dravable),
 можна дозволити ресайз (як в довжину, так і в висоту), вказати максимальні і мінімальні розміри,
 можна дозволити віджет до використання на головному екрані, чи на екрані блокування, чи там і там. 
 Можна вказвати різні лайаути для цих режимів. З допомогою метода AppWidgetManager.getAppWidgetOptions
 можна отримати bundle, звідки отримати інфу по розміру віджету, чи де він знаходиться (екран чи блокувіння).
 Такж є приклад ручногооновлення віджетів (відключається системне і пишеться код, який з допомогою
 AlarmManager вручну організовує оновлення).
 Ці приклади написані на модулі p1211_ListWidget.
 
p1231
По вмовчуванню IDE при компіляції підписує apk своїм дефолтним debug-ключом. Але для користування картами
і публікаціях на android-market потрібно підписувати apk своім ключом. В ide є свій матер для цього.
В уроці описано як це зробити. В android-studio зробити це можна для кожного з пакета вказавши в дереві
проекта самісертифікати.

p1241
Пакети (як в ява) в андроїді є індентифікаторами програм. Тобто якщопочати інстальовувати прогу, то вона
провірить спочатку чиє вже прога з таким же пакетом. Якщо є то звірить їх сертифікати: якщо вони співпадуть
то оновить прогу, якщо ні - то видасть помилку. Також пакети є ідентифікаторами пісочниць, в яких 
виконуються ці програми.

p1251_ViewPager
Приклад використання компонента для реалізації панелі з вкладками, переключення між якими проводиться
свайпом. Зверху можнавставити заголовок, або заголовок із кнопками. В двох словах необхідно реалізувати
абстрактний клас адаптера, який для кожної із сторінок створює фрагмент і відображае його.
Грубо кажучи реалізувати можна один з двох адаптерів, або написати свій. Перший з них завжди створює 
фрагмент сторінки, на яку переключаєшся, і слідуючий за ним фрагмент, але ніколи не знищує вже створені
фрагменти, тож він швидкий, бо створюється мінімум фрагментів, алезаймає більше памяті. Знищення відбувається
тільки після знищення самого адаптера.
Другий з них після створення нового фрагмента і переключення на поточний, знищує попередній. (при цьому
можна в onSaveInstanceState для кожного з фрагментів зберігати певні дані, і вони при будуть передані
при повторному створенні цих фрагментів (в параметр onCreate)).

p1261_MediaPlayer
Приклад музикального плеєра: в ньому показано як можна відтворювати аудіо з різних місць. Є кілька 
нюансів: якщо тре відтвоювати звук із мережі, то потрібно в маніфесті прописати android.permission.INTERNET.
Другий нюанс: підготовлення до відтворення може робитись двома методами: один синхронний, другий - асинхронний.
Після підготовки асинхронного метода спрацьовує подія, і таким чином при відтворенні з мережі не блокується
основний потік ГУІ. А якщо б такі дані ми підготовлювали синхронним методом, то в нас би інтерфейс фрізив.
Щодо відео: По поводу видео. Метод setDisplay позволяет указать плееру, куда выводить изображение. 
Размещаете на экране компонент SurfaceView (вкладка Advanced), вызываете его метод getHolder и 
полученный объект передаете в setDisplay. Плеер выведет изображение на этот компонент. Чтобы узнать размер 
проигрываемого изображения можно использовать методы getVideoHeight и getVideoWidth.

p1271_AudioPull
Приклад удіомікшера: об'єктдозволяє загрузити в свою память необхіднукількість файлів і запустити їх
на програвання. При цьому вони проігруються одночасно (вірніше накладаються один на одного, алезапустити
їх можна окремо, якаудіодорішки). При цьому в конструкторі можна вказати яку максимальну кількість доріжок
можна одночасно відтворювати. При цьому решту запущених доріжок ігноруються (при цьому порядок черги звуків
формується по вказаному в доріжці приорітету, а якщо приорітет однаковий - то які раніше запущені, ті і
вищі по приорітету проігрування). Для кожної доріжки перед запускомможна вказати скільки раз її проігрувати,
її гучність в правому і лівому каналі, міняти швидкість її проігрування, кількість повторів. При цьому
можна ставити як одну, так і всі доріжки, на паузу, і міняти параметри відтворення в процесі відтворення.
Мінус - всі аудіодоріжки завжди в оперативці. 
Цей об'єктдозволяє робити різні звукові ефекти, як наприклад в іграшках.

p1281_AudioFocus
Компонент дозволяє запрашувати аудіофокус в інших программ або реагувати на такі запроси від інших программ.
Наприклад якщо якийсь плеєр проігрує щось, наша программа може податми запрос на то щоб на час проігрування
нашого звуку плаєр поставився на паузу або напр. зменшив сво гучність і наоборот відреагувати на на такий
запрос.
Момент: для проігрування файлів із SDCard крім вказання дозволу в маніфесті додатково портібно в программі
програмно запросити цей доступ.

p1291_MediaRecorder
Приклад використання компонента для запису аудыо або выдеоконтента. В даному прикладі - запис. 
Спочатку його треба сконфігурувати (задати джерело контента, кодек, контейнер, отримувач,напр. файл),
а після цього prepare() і можна записувати. Якщо зупиняти через stop(), то для повторного старту
треба створвати новий об'єкт, якщо через reset, то тыльки наново його перелаштувати.

p1301_AudioRecorder
Клас - який являэться буфером: записведеться в внутрішній буфер, а далі ми вже можем по байтам читати
записане в буфер. При ініалізації завжди треб перевіряти мінімально-допустимий буфер. Також можна 
призначити дві події, які виконуються періодично (напр. кожних ен. фреймів) або при досягненні ен-го
записаного фрейму. (фрейм - це один записаний цикл, напр. це записаний 1 семпл, тобто якщо моно і
бітність 16 - це 2 байта).
Даний об'єкт зручно використовувати коли записані дані треба відразу передати або по мережі, або іншій
програмі, або т.д.

p1311_CameraIntent
Приклад як фоткати або знімати відео з допомогою встроєної програми камери (виклик інтента фоткання і
обробка отриманих данних після його закриття). Якщо дати на вхід інтенту шлях до файла, то він в той
файл і помістить фотку/відео. Якщо ні - то в випадку фотки він верне двійкові дані до фотки, а в відео -
шлях до знятого відео. При ініціації відео таклж в інтент можна передати такі параметри:
MediaStore.EXTRA_VIDEO_QUALITY – качество видео. 0 (плохое) или 1 (хорошее).
MediaStore.EXTRA_DURATION_LIMIT – лимит продолжительности видео в секундах
MediaStore.EXTRA_SIZE_LIMIT – лимит размера получившегося видео в байтах

p1321_CameraScreen
Приклад як зробити свій інтерфейс для камери: тобтро як відображати прев'ю з камери в своєму вікні.
При цьому в прикладі показано як підганяти розмір зображення камери до розміру вікна, а також враховувати
орієнтацію телефона. При цьому слід мати на увазі передня чи задня це камера і також початкову орієнтацію
камери відносно телефона (яка в різних моделей телефона може бути різною)

p1331_CameraRecord
Приклад к записувати з камери. Особливості:
1. Для фото використовується Camera.takePicture, який визиває калбеки при :спрацюванні затвора, отриманні
raw-картинки, отримання зжатої картинки (jpeg).
2. Для выдео використано MediaRecorder, використання аналогічне як для запису аудіо. Одна особливість:
перед записом тре викорристати Camera.unlock(), а після закінчення Camara.lock() (спочатку відключаєм
монопольний доступ прев'юхи до камери, об MediaRecorder зміг підключитись до камери, а в кінці вертаєм
все назад)

p1341_CameraFeatures
Робота з настройками камери: об'єкт настройок визивається з допомогою Camera.getParameters. В об'єкті
крім традиційних геттерів і сеттерів є сввої набори методів для оприділення чи та чи інша функція
підтримується пристроєм, отримання набору можливих значень тої чи іншої настройки, або отримання максимально
можливого значення тої чи іншої настройки. В даному прикладі - це режми спалаху і кольорові трансформації.
Нажаль помацати не вдалось через обмеження емулятора.

p1351_Loader
Приклади використання таких штук як лоадерию По факту лоадери - це класи які ми можемо прив'язати до 
актівіті чи до фрейма і винести в них виконання певних процесів. Якщо створювати лоадери при створенні 
актівіті, то їх життєвий цикл буде прив'язаний до життєвого циклу актівіті. Стартувати і впливати на
ловаде можна із актівіті чи фрейма з допомогою LoaderManager. Зворотня взаємодія можлива через реалізацію
колбеків, які і визиватимуться з лоадера (їх можна як реалізувати в самому актівіті, так і на стороні).
Лоадери можна робити і субкласами фрагмента, але тоді він цей субклас має бути оголошений статичним.
Життєвий цикл: коли в менеджері визвати initLoader, то сворюється івертається сам лоадер і в ньому викликається 
onCreateLoader. Якщо resetLoader, то активний лоадер тушиться (в ньому виконується onAbadon), далі
створюється і запускається новий екземпляр лоадера. Якщо потрібно получитьти вже існуючий активний 
лоадер, то виконується метод getLoaderManager().getLoader(id) в актівіті. Якщо вернувся нулл, то
лоадера з таким айді неіснує. Щоб запутстити процес в лоадері, використовується його метод forceLoad(), 
його і треба переопреділити в лоадері. Після його виконання результат і передається в колбек, реалізований
в Activity (в onLoadFinished). При виході з актівіті, його перестворенні (коли спочатку він знищується), 
лоадер також знищується. Спочатку для кожного лоадера виконується його onStopLoading, потім для активного
лоадера спрацьовує його колбек onLoaderReset, і далі для кожного з лоадерів їх onReset. Відповідно: 
якщо ви запустили forceLoader, а потім згорнули актівіті, вийшли з нього, або поміняти орієнтацію (що
викличе перестворення актівіті і відповідно лоадера), то після завершення роботи в запщеному лоадері
колбеки не спрацюють і нічого не відбудеться.
Також є можливіть повідомити лоадер що дані оновились, і необхідно поновити свої дані, і це робиться 
з допомогою ContentObserver можна виставити флаг змін в Loader-рі (dispatchChange) і при цьому лоадер
коли це побачить сам запустить forceLoader. 
Також є такий клас як AsyncTaskLoader, який можна використовувати замысть попереднього, але він виконує 
роботу в окремому потоці. Реалізовувати логіку роботи вже треба в його loadInBackground(). При цьому
є можливіть його перервати через cancelLoad() що визове колбек onCanceled.
Також э можливість вказання мінімально-можливого часу між запусками лоадера. Тож новий лоадер запуститься
тальки після проходження цього мінімального часу.

p1361_CursorLoader
Переробка 52-го прикладу: там для вивода з бази даних використовувався SimpleCursorAdapter, і він об'явлений
застарілим. Тута же використаєм Loader, який кожного разу асинхронно віддає новий курсор, а ми його
будем заміняти в адаптері (adapter.swapCursor()). При цьому все відбуваються асинхронно, без блокування
інтрфейсу, в інших ветодах лоадера вірно можна опрацювати звільнення ресурсів, ініціювати перечитування
данніх при їх зміні і т.д. 

p137x-sensors
Приклад як читати дані з сенсорів. Сенсори можна отримати через SensorManager, де можна 
взнати характеристики тих чи інших сесорів. Якщо для певного сенсора вертається нулл, то його
в пристрої немає. Також до того чи іншого сенсора можна через менеджер вчіпити лістенер (імплементувати
SensorEventListener, в якому і фіксуються зміни сенсорів, також при обробці бажано копіювати
дані на бік, так як дані передані в обробник можуть змінитись неодночасно (напр. дані
по осі x зміняться до того як зафіксувався в у, і в нас получаться неадекватні дані)).
Цікаві приклади в нас тут є по трансформації отриманих даних  в на потрібні (напр. врахування орієнтації
в певних моментах, перерахунок вектора в часті градусів і т.д.). Також варто знати шо сенсори бувають
реальні і віртуальні, наприклад акселерометр - це реальний сенсор, а сенсор сили тяжіння, чи чистого
прискорення - віртуальні, які самі собі розраховуються з реального і мабуть ці дані навіть точніші.
Також в маніфест можна добавити <uses-feature android:name="android.hardware.sensor.accelerometer" android:required="true" />,
що скаже щоб Google Play не ставив прогу на апарат без акселерометра.

p1381-location
Приклад отримання даних геолокації. Функціонал майже повністю як із 1С, також і схожі методи роботи.

p1391-googlemaps
 Приклади використання в проекті карт Гугл. Також є невеликі особливості:
 1. В AndroidStudio добавити бібліотеки GooglePlay
 2. В модуль проекта (в дереві проекта) підключити бібліотеки google maps і google play
 3. Необхідно в маніфест прописати ключ карт гугл і добавити пропис версії 
 бібліотеки плей-маркета (через int@)
 4. В маніфест також треба добавити кілька дозволів і, якщо треба, дозволи геолокації.
 - також приклади як позиціонувати карти і переключати інтерфейси, добавляти рюшечки...
 
p1401-googlemapsdraw
 В даному прикладі як на карти добавляти об'єкти: напр. маркера, полілінії і т.д.
 Із нового і цікавого 
 - як можна переопреділити інформаційне віконечко по кліку на піктограму своїм віконечком.
 - для поліліній і полігона можна включити geodesic - тоді лінії будуть малюватись по поверхні землі.
 - в полігоні метод AddHole, яким можна накидати "діру" в полігоні
 - є можливість добавити маркер як картинку, яка буде розтягуватись разом з картою при зумі.
 
p1411 - canvasview
Прикладии як малювати на екрані. Для цього в простому варіанті при створенні актівіті в setContentView
передаєм свій розширений класс View, в якому переопреділяєм метод onDraw, яким система і проводить 
малювання, там ми і можемо вклинитись. Але тут можна і правильно робити тільки самі простіші речі.
В другому прикладі вже більш правильний, але ресурсоємкий метод рисування через розширення SurfaceView і
реалізацію SurfaceHolder.Callback, де ми можемо винести це все в окремий потік.

p1421 - drawingfigure
Приклади малювання по канві: створюється об'єкт Paint (типу олівець), яким малюємо з допомогою різних
методів різні фігури на канві. Чимось смахує як колись малювали в бесіку, але об'єктно

p1431 - drawingpath
Приклади як малювати складніші фігури шаблонами. Накидується шабло н допомогою об'єкта path, який вже
з допомогою paint виводиться на canvas. В приладах є як виводити криві і відносно яких опорних точок, 
також є приклади як виводити текст по колу.

p1441 - matrixtransform
Викорстання матриць для трансформування нарисованих фігур (напр. зміщення, скручування відносно точки,
поворот навколо осі відносно точки). Також цікаво в матриці є методи pre* і *post, якими можна добавити 
ще трансформацію до або після основної (напр. можна перед поворотом відносно осі добавити зміщення, і
тоді перед поворотом спочатку пройде зміщення фігури (але не точки навколо якої буде поворот),а потім 
поворот). 
Також цікаві методи map*, які дозволяють обчислити границі фігур, які можуть получитись в результаті
перетворення матриці.
Є і методи які дозволють сумувати і робити інші операції на трансформаціями двох матриці (добавляти 
одні послідовності до інших і т.д.

p1451 - matrixtransform2
Приклади трансформації з допомогою двох методів:
-setRectToRect - на вхід бере два квадрата і наоснові них будує матрицю трансформації так, щоб один квадрат
перетворювався в інший, а далі з допомогою цієї матриці можна трансформувати вже існуючі об'єкти. При цьому 
можливо додатково вказати параметри так як, напр. збереження пропорцій вихідного зображення, вт=ирівнювання
в разі того коди в вихідному квадраті будуть залишатись вільні області.
-setPolyToPoly - потужний і трохи важкий для розуміння: дозволяє построїти матрицю перетворення одного масиву
точок в інший масив точок. При цьому дозволяється використовувати до 4-х точок.
Якщо використати тільки одну точку, то здійсниться просте переміщення трансформованої фігури. Якщо дві: тоді зміщення, поворот
і масштабування, якщо три - то зміщення, поворот, масштабування, наклон, а в разу якщо добавити 4-ту, то
ще й дозволить додастся перспектива. При цьому метод вертаєбулєво, яке виставляється в ложь, якщо побдувати 
матрицю трансформації не вдалось.

p1461- canvastransform
Канва має свою власну встроєну матрицю. Саме тут приклади як можна її використовувати. Також приклад як
можна використовувати стек станів матриці: туди можна зберігати стани матриці і звідти їх відновлювати.

p1471 - region
Приклад використання об'єкта Region. Цим об'єктом ми можемо клеяти фігури. При цьому в більшості випадків
використовуються прямокутні області. Їх можна клеяти ріними режимами (різницею, злиттям, різницею, і т.д.).
Ітератором можна побачити з кількох простих квадратних областей складається результуюча фігура і т.д.

p1481 - canvasclip
В канви є метод clip, яким ми можемв становлювати область рисування по канві, тобто рисувати ми можемо
по всій канві, але в реалі все що буде за встановленою цим методом областю буде обрізатись. Відмінити обрізання,
або відкатити до попереднього можна, як ми в попередніх уроках ми бачили, можна методом restore.

p1491 - canvastext
Вивід текста на канву. В часності: можна виміряти ширину виведеного тексту, посимвольні ширини (в першому
прикладі). В іншому прикладі можна побачити як взначи скільки символів вліззеться в певну ширину (як з початку
тексту так і з кінця), а також яку ширину має певна кількість символів в сумі.
Також приклади як можна міняти шрифти тексту, розтягувати, форматувати його, можна
навіть вказувати розміщення букв посивмольно (розкидувати по екрану)

p1501 - pathmeasure
PathMeasure - об'єкт для виконання операцій над Path, наприклад отримати матрицю
трансформації по певній точці на нарисованій Path, характеристики (позиція, нахил), отримати загальну 
довжину Path, отримати контури з Path і чи вони замкнуті чи ні, отримати частину Path.

p1511 - pathefect
pathefect - приклад як можна до Path приплітати ефекти, напр. setPathEffect(new CornerPathEffect(50))
закругляє кути ломаної лінії, setPathEffect(new DiscretePathEffect(10,15)) - робить прямі частини ломаними
(так як би п'яний малював лінію), setPathEffect(new DashPathEffect(new float[] { 30, 10}, 0)) - малювати
лінії різними пунктирами (пунктирами різних характеристик). Аналогічно можна малювати лінії своїми 
Path: наприклад намалювати лыныю стрілками чи іншими фігурами, при чому вони можуть бути вистроєні в 
напрямку лінії або просто так. Аналогічно ефекти можна комбінувати (накладати один за одним, або сумувати),
при цьому має важливість порядок накладання.

p1521 - paint
Об'єкт дозволяє записувати все виведене в себе, а потім за один прохід вивести запис на канву, при цьому
вказується ширина і висота, а потім при виводі можна це транслювати на свою довільну область (в яку
воно відповідно змаштабується).

p1531 - colorfilter
приклад як можна трансофрмувати кольора: можна простим вказанням коефіцієнтів для кожного з каналів, 
можка вказанням матриці трансформації (5*4), да на кожен канал (ARGB) кожен рядок, а в рядку коефіцієнти
трансформації відносно інншик каналів (4) + константа зміщення (просто добавляється до результату зміщення).
Аналогічно є методи для вказання коефіцієнту насичення кольору, також і повороту (тре вже експерементувати), 
Також є клас LightingColorFilter, яким можна компонувати кольора (метод add добавляє канали одних кольорів
до каналів інших і потім урізає їхдо 255, mull переводе канали в долі одиниці і перемножає їх, потім 
вертає назад в розмірність 255).

p1541 - porterduff
Об'єкт, який дозволяє змішувати по кольору два зображення на Paint-ах (два Paint).
При цьому э кілька режимів змішування, як по кольору, так і по заміщенню намальованих областей
canvas (або перший головний, або другий, або керуючись логікою XOR).

p1551 - porterduffcolorfilter
Приклад як попередніми porterduff можна наложити суцільний кольор на картинку із зміщанням
кольорів згідно з porterduff-режимами, правда тут умісні в основному накладання суто із зміщанням
кольорів, а не накладання згідно з режимами.

p1561 - porterduffcolorfilter - deprecated, а заразвзагалі вилучили цей клас, тож прпускаю

p1571 - bitmapread - приклад читання зображення bitmapЁ отримання його даних (характеристик), а
також його виведення з транформацією на канву.

p1581 - bitmapcreate - ствоення свого бітмапу. Пудтримуються три основних методи: 
сворення копіюванням існуючого (з певними параметрами), створення значеннями кольорів
пікселів з масиву, або створення пустого бітмапа (який якщо передати в конструктов
canvasa можна ним щось намалювати). При створенні бітмапу також є такий метод як 
dencity, який можна вказати плотність пікселів. При виводі його кудись в середовище
з іншоюпіксельною густиною він відповідно буде розтянутий/звужений

p1591 - BitmapFactory використання деяких специфічних опцій фабрики бітмапів (якою можна
декодувати бітмапи з резурсів).
inJustDecodeBounds - вказує що вертати бітмапи не треба, а тільки інформацію про них.
inSampleSize - загрузка з кратним зменшенням (Кратним двойки)
inBitmap - якщо передати туди вже створений бітмап, то читання буде проведено в нього, а не створено новий
Також є приклад збереження картинки з бітмапу в файл на карточці

p1601 - bitmaplarge
При читанні великої картинки воно в памяті завжди тримається в розпакованому вигляді (незалежно
з якого формату файлу воно прочитано) і може займати 50 мегабайт опери і т.д. То ж коли 
відображати кілька таких файлів, то спокійно мош зловити нехватку памяті. Щоб цього не було,
прикидують потрібний розмір для відображення і читають файл з одночасним ресайзом (як в
попередньому прикладі). Тут приклад як це робити.

p1611 - bitmapcache
В даному прикладі реалізація адаптора для виводу картинок в список.
В першій реалізації - тормоза при прокрутці, бо храмає підгрузка з файлів.
В другій використання кешування в пам'яті через LruCache, але також тормоза тільки при першому прогортуванні.
В третій використання асинхронної підгрузки картинок. Для простоти і прикладу використання сторонньої 
бібліотеки Picasso (вона і має кеш і асинхронну підгрузку)

p1621 - drawableshape
Використання контейнера drawable для виводу на канву. 
Контейнер може виводити як програмно нарисовані об'єкти, так і підгружені зресурсів. В даному випадку 
приклади drawable з тегом <shape> (із ресурсів)

p1631 - drawablexml
Використання контейнера drawable для виводу на канву фона в вигляды картинки. Також приклад, де їх 
(різні Drawable) можна виводити слоями одну за одною. Також є приклад де можна вказувати які Drawable 
виводити на View-и залежно від їх стану (напр. на нажату кнопку - одну, відпущену - іншу).

p1641 - drawablexml1
Приклади як можна також застосовувати трансформації при виводі: обрізання, розтягування/зжимання, анімації,
переходи (transition)

p1651 - Shaders
Шейдери - це кли ми рисуєм, і на рисовані фігури заповняємо текстурами, приклади.

P1661 - OwnDravable
Приклад як використвувати не системні Drawable, а реалізувати свій власний Drawable. 

p1671 - savelayer
В будь який момент можна зберегти вміст виведеного з канваса і відновити пізніше цей слой на канвас.
В даному випадку приклад як це використати.

p1681 - OpenGl
Простенький приклад як використовувати OpenGL для виводу графіки: в даному прикладі ініціалізація об'єктів
необхідних для виводу: GLSurfaceView - аналог Canvas, свій клас імплементуючий інтерфейс GLSurfaceView.Renderer -
аналогічний по призначенню з Paint. 
Додатково при ініціалізації з головного Activity необхідно провести перевірку на підтривувану девайсом 
версію OpenGL ES, а також підключити події onPause і onResume до GLSurfaceView (необхідно для реалізації
нормального життєвого циклу об'єкта GLSurfaceView).
Результам роботи є ініціалізаці GLSurfaceView дефолтним кольором фону.

p1691 - OpenGL shader
Вивід простішого шейдера: трикутника. Вивід шекдера приблизно робитс так: сторюється файли коду компіляці
двох складових (вершинного і фрагментного шейдерів) - на спеціальній мові шейдерів. В коді описуєтьс
код по створенню шейдера, де описуються вхідні атрибути і алгоритм формування внутрішніх шейдерів з них.
Далі в коді читаються тексти цих кодів, компілюються шейдери, з цих двох шейдерів робиться об'єкт 
програми виводу і підключається. Далі в коді прописується як дані прописуються в коді шейдерів (в 
оголошені в коді шейдерів змінні). 

p1701- OpenGL Primitives
Приклади як аналогічно до попереднього прикладу виводити фігурина прикладі трикутника, лінії, точки.
При цьому для ліній і трикутників є три різних режима вивода.

p1711 - OpenGL Colors
В даному прикладі показано як реалізукти передачу кольору в шекдер: як просто кольор в примітив, так і
передачу різних кольорів вершинам одного примітиву. Тоді автоматом кольора по мірі переходу з одної
вершини в іншу будуть інтерполюватись з одного кольору в інший (градієнт).
В шейдерах може бути 3 види змінних: attribute - передача константи конкретної вершини, uniform - константа, яка присвоюється
всім вершинам, і varying - змінна яка використовується для передачі данних з вершинного шейдера в 
фрагментарний (в нашому випадку це кольори вершин, які передаються для того щоб спрацювала інтерполяція-градієнт)

p1721 - OpenGL Perspective
Даному прикладі як через OpenGL робити перспективу. Можна просту робити через передачу 4-го даного в 
координатах (координата W). Координата Z в даному випадку не дуже підходить, бо насправді в нас 2D і
дана координата просто показує яка фігура над якою рисуватиметься (слой).
Складніші можна через використання матриці трансформації. В нашому випадку все пишем в координату Z (4-ї
не треба), створюємо матрицю трансформації. Саме її і передаємо в шейдер. Матрицю ініціалізуєм при 
події onSurfaceChanged. Там же можна і дописати код на поправку до орієнтації (щоб при зміні орієнтації
екрану співвідношення шейдерів не мінялись.)
Важка тема - варто ще потім раз перечитати.
Тези:
1) Наш экран - двумерный. Соответственно, чтобы вывести на него изображение, система использует только x и y координаты. Координата z используется для определения какую точку выводить, если у нескольких точек совпадают xy-координаты, и трехмерности она никак не добавляет. Для придания картинке трехмерности используется w, с ее помощью система эмулирует перспективу.
2) Мы в своем приложении хотим описывать трехмерный мир и использовать для этого трехмерную систему координат XYZ.
3) Матрица перспективы позволяет нам реализовать хотелку из п.2. Она выполняет преобразования виртуальных трехмерных координат в двумерные (п.1), чтобы система смогла нарисовать изображение, которое выглядит как трехмерное.
4) Трехмерное изображение ограничивается со всех сторон фигурой, которая является призмой или усеченной пирамидой, и называется frustum. В вершине пирамиды находится камера, т.е. точка, из которой мы "смотрим" на изображение. Взгляд камеры проходит насквозь через frustum.
5) По умолчанию, камера находится в точке (0,0,0) и смотрит вдоль оси z в сторону убывания.

p1731 - OpenGL View
Тут уже цікавіше - крім перспективи управління камерою, з якої ми дивимся на птипу предмет. При цьому
при ініціалізації потрібно вказати дві точки (точка розміщення камери, точка куди направлена камера) і
векторб який показує як повернута камера навколо осі погляду. При цьому дані заганяються в шейдер так:
створюється матриця погляду (камери) і перемножається з матрицею проекції. Результат і запихається як
матриця трансформації в шейдер (як в попередньому прикладі)).

p1741 - OpenGL Model
В даному випадку добавляэться ще третя матриця (матриця перетворення), яка сумується до матриць проекції
і матриці камери, і в такому вигляді передається в шейдер. Показано як робити переміщення (translate),
розтягування (scale), поворот (rotate). Особливість розтгування: при вказанні від'ємного значенення
по осі приводить до зеркального відображення по осі. 
При повороті необхідно вказати кут повороту і координати точки осі (проводиться вісь із центу координат
до вказаної точки і вже відносно неї проводиться поворот навколо осі за годинниковою стрілкою на вказаний
кут.)
Із інших слів по коду все проводиться так:
Еще раз распишу на всякий случай, что вообще происходит.
1) В методе prepareData мы подготовили в массиве данные по вершинам, а в методе bindData передали их вершинному шейдеру. Эти методы у нас были вызваны один раз в самом начале, в методе onSurfaceCreated. Т.е. мы передаем данные по вершинам только один раз, а не каждый кадр!
2) При отрисовке каждого кадра система вызывает метод onDrawFrame. В нем мы вызываем glDrawArrays, в котором указываем какие вершины (из тех, что мы передали в пункте 1) шейдер должен взять и какой примитив из них нарисовать.
3) Кроме этого, в onDrawFrame мы пересчитываем матрицу и передаем ее в шейдер. Т.е. мы делаем это не один раз в самом начале, как вершины, а именно каждый кадр. И т.к. мы каждый кадр настраиваем model матрицу с помощью метода rotateM и постоянно меняющейся переменной angle, то каждый новый кадр итоговая матрица содержит данные, отличающиеся от данных которые она содержала во время отрисовки предыдущего кадра.
4) В итоге, каждый кадр шейдер берет данные, которые мы передали ему в пункте 1, применяет к ним полученную в текущем кадре итоговую матрицу и отдает системе рассчитанные координаты вершин. В результате каждый новый кадр объект рисуется на другом месте и именно это дает нам анимацию.

p175x - OpenGL Textures
Приклад як замість заповнення кольором використовувати текстури. Для цього потрібно створити об'єкт 
текстури. Текстури бувають кількох типів: GL_TEXTURE_2D і GL_TEXTURE_CUBE_MAP. Ми будемо працювати
з першим (проста двовимірна текстура). Для сворення текстури активувати певний юніт слота текстури (
при цьому далі по ідентифікатору будемо звертатись до текстури), далі загрузити картинку з Bitmap, 
помістити об'єкт текстури в один з TextureTarget (в нашому випадку GL_TEXTURE_2D), післ чого вже іменно
для GL_TEXTURE_2D необхідно передати йому картинку і налаштувати режими фільтрації (режими окремо для
розтягування тектури і окремо для зжимання, якщо вона по розмірах не співпадає з шейдером). 
А далі в ФрагментарнийШейдер потрібно подати номер юніта, куди загружений об'єкт текстури (той юніт 
який ми перед цим активували). Також по аналогії з кольором нам необхідно з вершинного шейдера передати
в фрагментарній інфу, як співставляти вершини з текстурою. Текстура має свою координатну сітку (x, y)
в межах від 0 до 1f, початок ординат в верхному лівому куті картинки текстури, тож для кожної вершини
крім її координат (x,y,z) передаєм також координати точки текстури (x,y), яка їй відповідає, а далі
по аналогії з кольором передаєм цю інфу з вершинного шейдера в фрагментарний.
Далі є приклад як можна використовувати кілька тектстур і малювання простого кубіка з допомогою текстур
і обертання результату.

p1761 - OpenGL Cube
Приклад як кубик, як в p1753 зробити з допомогою текстури GL_TEXTURE_CUBE_MAP. При цьому потрібно при
створенні об'єкту текстури призначити 6 картинок (4 боки + верх і низ), а при загрузці даних вершин
не робити відповідність координати картинки вершині, а створити масив де по порядку описати індекси 
вершин трикутника, які відповідають кожній із граней. А далі передати ці дані в вершинний шейдер
з допомогою метода glDrawElements. В вершинному шейдері перетворювати Position vec4 в тип vec3 і передати
в фрагментарний шейдер, а там вивести це з допомогою метода "textureCube". При цьому шейдера маючи
ці дані самі розберуться на яку частину куба яку картинку накладати
От тільки для роботи всього цього необхідно щоб центр куба завжди знаходився в центі координат, інакше
текстури накладаються некорректно (хоча так сказано в уроці, не факт що воно так є)

p1771 - 1791 - чомусь відсутні

p1801 - ConstrainLayout 
Лайайт з прив'язками, де всі елементи прив'язуються до своїх батьків з однієї зі сторін. Якщо з якоїсь
із сторін прив'язка не налаштована то елемент пригає до початку екрану (з тієї сторони), а в студії 
показує помилку прив'язки. Якщо прив'язка тільки з обного боку орієнтації то вона статична (в пікселях
і відображається лінійкою), якщо з двоїх то в відсотках (відображається зигзагом). Також можна прив'язуватись
не тільки до батьків, а й до сусідніх елементів.

p1811 - приклади прийомів роботи з побудовою прив'язок. До речі інструменти в панелі дуже схожі на
аналогічні в 1С 8 звичайних форм. Із цікавих можливостей - це приклад прив'язки наприклад текст-едітів
з різними шрифтами по нижній лінії тексту (вирівнювання по шрифту), також для елементів які розтягуються
по висоті і ширині розтягування з фіксованим співвідношенням сторін (Fixed aspect ratio). Включаэться в
менюшці панелі властивостей елемента в трикутнику верхнього лівого кута схеми. Також в схемі можна переключати
режими ширини елемента (фіксована, wrap_content чи match_constraint)

p1821 - chain - прийоми роботи з ConstrainLayout
- Також є поняття  ваги : співвіідношення величини елементів згідно коефіцієнту ваги, але тут воно
повинно налаштовуватись через группу атрибутів Constrains.
- Елементи можна об'єднувати в цепочки. Для цього треба виділити кілька елементі і
натиснути кнопку розприділення їх по ширині (або висоті). Тоді крайні елементи прив'яжуться
до країв контейнера, а між собою з'єднаються ланцюжком, режим роботи якого
можна міняти відповідною піктограмою.
- Є така штука як бар'єри: це ніби вирівнювальні лінії. Приклад викоритання: є два
елементи які можуть довільно розтягуватися і потрібно доавти третій збоку так,
щобб він не заїжджав за два перших. Для цього добавляється бар'єр, до якого необхідно
приєднати два елементи, а третій прив'язати до бар'єра. Тобто по факту бар'єр - це лінія
при'язки, яко приєднана до края найбільш виступаючого на даний момент елемента.
- також є така штука як групи. Добавлячи елементи в групи потім через об'єкт групи
в коді можна звертатись до групи і міняти атрибути групи (наприклад розмір шрифта), при
цьому поміняются ці атриути всіх елементів, які водять в групу. При цьому перелік
атрибутів групи залежить від виду елементів, які входять в группу.
- layout_constraintCircle, layout_constraintCircleRadius, layout_constraintCircleAngle, через
ці атрибути можна організувати прив'язку, коли один елемент прив'язується до іншого так:
в першому вказується об'єкт прив'язки, в другому - радіус кола, а якому знаходиться прив'язуємий
елемент (а елемент до якого в'яжемся - в центрі), а в третьому - кут між вертикаллю і
радіусом, який з'єднує центри цих двох елементів.

p1831 - ConstrainSet
Приклад програмної роботи з ConstrainLayout. При цьому використовується об'єкт ConstrainSet. Ним проводиться
створення, редаугвання элементів, їх прив'язок, а далі накопичені зміни накатуються на ConstrainLayout,
також можна скопіювати всі дані елементів з ConstrainLayout, відредагувати і назад їх загнати.
P.S. З невідомих причин спрацьовують не всі елементи які б мали спрацювати. На форумі - мовчок, і в мене
вроді все ок зроблено. Короче не дуже зрозуміло в чому причина.

p1841 - Notification
Прості приклади для роботи з повідомленнями. З цікавого: відкриття по кліку,
прогресбар в повідомленні, заборона закрити повілдомлення. Є можливість
вказати таймаут показу повідомлення. В тексті уроків є додаткові приклади
оформлення.

p1851 - Notification Activities
Приклад емуляцій реалізації задачі: є три Activity. Одне типу список листів,
друге - деталізація листа, третє - вікно пропонування оновлення програми.
Смисл: при появі нового листа виводиться повідомлення нового листа, при
нажиманні на яке відкривається сам лист. При цьому повідомлення зникає. Але
відкривається лист таким чином, що в стеку відкритих актівіті завжди є головне вікно
(при кнопці назад незалежно від попередньо відкритого вікна все завжди вертається
в головне вікно списку листів.
Вікно оновлення має також свої особливості: ця актівіті завжди відкривається
в овремому таску і при закритті не відбражається в історії відкритих вікон
(а при відкритті листа в списку вікон відобразиться два актівіті).
Особливості: вікно таска і відображення в історії конфігурується флагами
Activity.
Принадлежність DetailsActivity до MainActivity конфігурується в маніфесті
(двома рядками для вражування версій сумісності), і потім використовується
TaskStackBuilder.
Також закриття нотифікації проводиться в DetailsActivity, бо якщо в неъ зайшли
напряму, то нотифікацію закрити також треба.

p1861 - Notification Extended
Приклади додаткових оформлень повыдомлень (напр. великий текст, велика фотка,
кілька рядків, тексти меседжів...)

p1871 - Notification button reply
Приклад як можна до повідомлення добавити кнопки (до 3-x) або організувати
відповідь (по кнопці відкривається поле вводу, звідки можна обробити відповідь).

p1881 - Notification extended
В даному випадку приклад як можна мутити кастомні повідомлення (лайаут грузиться
з ресурсів і підставляеться в повідомлення). Є два приклада - старий і новий.
В першому повністю все повідомлення кастомне, а в другому - воно підставляється
замість текста (можна використовувати кнопки, реплаї, заголовки та інше з
попередніх прикладів).
Висота лайаута стандартного повідомлення: 64dp, великого (розгортаємого) -
не більше 256dp.
Також для нормального відображення на різних пристроях елементам лайаута
рекомендється призначити стиль з "@style/TextAppearance.Compat.Notification.*"

p1891 - Notification grouping
Групування повыдомлень: створюємо повідомлення, в них вказуємо ключ группи.
В кінці створюємо повідомлення з таким же ключем і в білдері крім ключа добавляєм
setGroupSummary(true), і тоді повідомлення робиться групою, вбираючи повідомлення
в себе. При цьому группу потрібно вказати вкінці, інакше нічого не вийде,
і ключ повідомлення також повинен бути унікальним.

p1901 - Notification channels
Починаючи з Android 8 введено канали повідомлень, і користувач в налаштуваннях
для аплікухи може керувати відображенням цих каналів (чи відображати повідомлення
каналу, як їх відображати). В даному прикладі показано як їх можна добавляти,
удаляти, читита їх налаштування.
Приклад використання: email: группи це акаунти, а канали - це наприклад повідомлення,
або нові листи (в группах вони відобразаяться по каналах)
При роботі обов'язково потрібно проводити перевірку на версію Android.